package simpleDifferentiation.rj;

import java.text.DecimalFormat;
import java.util.EmptyStackException;
import java.util.Stack;
/**
 * Used for differentiating postfix expressions. Will only work
 * with the variable 'x'. No brackets should be used; only parenthesis. Formatting is 
 * extremely important in order for this class to work properly. Postfix expressions 
 * should be generated using the Expression class to guarantee that terms are read 
 * properly. Answers generated by any method of this class will not always be in its simplest form. 
 * @author Ryan Jung
 *
 */
public class Calculator {
	private Expression expression;

	public Calculator(Expression expression){
		this.expression = expression;
	}
	
	/**
	 * Differentiates the expression that was given when this instance was created.
	 * @throws InvalidExpression If a term can't be read or there are more operations
	 * then operands.
	 * 
	 */
	public String differentiate() throws InvalidExpression{
		return differentiate(expression.getPostfixExpression());
	}
	/**
	 * Evaluates a postfix expression and returns the answer. Each term must be separated
	 * with commas(Parenthetical Expressions are considered as a single term). Uses a stack
	 * to differentiate a postfix expression, similarly to how one may use a stack to evaluate
	 * a postfix expression.
	 * 		Example : 5x,(5x^5+5)^5,-
	 * @param expr - A valid postfix expression.
	 * @return The unsimplified derivative of an expression.
	 * @throws InvalidExpression - If a term can't be read or there are more operations
	 * then operands.
	 */
	public String differentiate(String expr) throws InvalidExpression{
		
		Stack<String> termStack = new Stack<String>();
		
		int i = 0;
		
		//if there is only one term in the expression
		if(Reader.readTerm(expr, i).length() + 1 == expr.length()){
			return getDerivative(Reader.readTerm(expr, i));
		}
		
		while(i < expr.length()){
			int opToDo = checkOperation(expr.charAt(i));
			//Prevent negative sign being read as subtraction in the beginning of expression
			if( i == 0 ){
				opToDo = -1;
			}
			//push terms to stack until operation is encountered.
			if(opToDo < 0){
				String term = Reader.readTerm(expr, i);
				termStack.push(term);
				i += term.length() + 1;
			}else{
				try{
					//do operation and put back on stack
					doOperation(termStack, opToDo);
					i++;
				}catch(EmptyStackException esex){
					throw new InvalidExpression("Cannot evaluate. More operations "
							+ "than operands");
				}catch(InvalidExpression iex){
					throw iex;
				}
			}
			
		}
		return termStack.pop().replaceAll("[&]", "");
	}	
	/**
	 * Returns 1 for addition, 2 for subtraction, 3 for multiplication, 4 for
	 * division, and -1 if not an operation.
	 * @param charToRead
	 * @return An integer representing the operation.
	 */
	private int checkOperation(char charToRead){
		if (charToRead == '+')
			return 1;
		else if (charToRead == '-')
			return 2;
		else if (charToRead == '*')
			return 3;
		else if (charToRead == '/')
			return 4;
		else
			return -1;

	}
	/**
	 * Pops two terms off the term stack and conducts the appropriate operation
	 * for those two terms. Once the resulting derivative has been evaluated
	 * adds an '&' to the end of the result indicating that the term has already been
	 * differentiated and then pushes back the result to the term stack. 
	 * @param termStack - A stack containing the expression's terms
	 * @param opToDo - An operation (1 = '+' , 2 = '-' , 3 = '*', 4 = '/').
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	private void doOperation(Stack<String> termStack, int opToDo) throws InvalidExpression{
		String result = "";
		String term1 = termStack.pop(); 
		String term2 = termStack.pop();
		switch(opToDo){
			//addition
			case 1:		
				// '&' implies derivative has already been calculated for a term
				if(term2.contains("&")){
					result = sumRule(term1, "")+ "+" + term2;
				}else if(term1.contains("&")){
					result = term1 + "+" + sumRule("", term2);
				}else{
					result = sumRule(term1, term2);
				}
				break;	
			//subtraction	
			case 2:
				if(term2.contains("&") && !term1.contains("&")){
					result = term2 + differenceRule("" , term1);
				}else if(term1.contains("&") && term2.contains("&")){
					result = term2 + "-" + term1;
				}else if(term1.contains("&") && !term2.contains("&")){
					result = differenceRule(term2, "") + "-" + term1;
				}else{
					result = differenceRule(term2, term1);
				}	
				break;
			//multiplication	
			case 3:
				result = productRule(term2, term1);
				break;
			//division	
			case 4:
				result = quotientRule(term2,term1);
				break;		
		}
		result+= "&";
		
		termStack.push(result);
				
	}
	/**
	 * Applies the product rule (https://en.wikipedia.org/wiki/Product_rule)
	 * to two terms. Does not fully simplify the answer.
	 * @param term1 - A simplified term eg. "25x^2" instead of "5^2x^2".
	 * @param term2 - A simplified term eg. "25x^2" instead of "5^2x^2".
	 * @return 
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public String productRule(String term1, String term2) throws InvalidExpression{
		String derivTerm1 = getDerivative(term1);
		String derivTerm2 = getDerivative(term2);

		String term1TimesDerivTerm2 = "";
		String derivTerm1TimesTerm2 = "";

		term1TimesDerivTerm2 = multiply(term1,derivTerm2);
		derivTerm1TimesTerm2 = multiply(derivTerm1, term2);
		
		return derivTerm1TimesTerm2 + "+" + term1TimesDerivTerm2;
	}
	/**
	 * Simply adds a the multiplication operator '*' between the two terms
	 * and returns the String "term1*term2". Does not do any sort of simplification.
	 * @param term1 
	 * @param term2  
	 * @return the result 
	 */
	private String multiply(String term1, String term2){	
		return term1 + "*" + term2;
	}
	/**
	 * Applies the quotient rule (https://en.wikipedia.org/wiki/Quotient_rule) for 
	 * differentiation involving division. The resulting answer will not be in its simplest
	 * form.
	 * @param term1 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on the left
	 * side of the '/' sign.
	 * @param term2 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on the right
	 * side of the '/' sign.
	 * @return
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public String quotientRule(String term1, String term2) throws InvalidExpression{
		
		String derivTerm1 = getDerivative(term1);	
		String derivTerm2 = getDerivative(term2);

		String derivTerm1TimesTerm2 = multiply(derivTerm1, term2);
		String derivTerm2TimesTerm1 = multiply(derivTerm2,term1);
		
		String numerator = "(" + derivTerm1TimesTerm2 + "-" + derivTerm2TimesTerm1 + ")";
		String denominator = "";
		
		denominator = "(" + term2 + ")" + "^2";

		return numerator + "/" + denominator; 
	}
	/**
	 * Applies the sum rule (https://en.wikipedia.org/wiki/Sum_rule_in_differentiation)
	 * on two terms. Does not simplify after sum rule is applied. A valid simplified
	 * term using the 'x' variable is expected in order to work properly.
	 * @param term1 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2".
	 * @param term2 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2".
	 * @return the unsimplified derivative
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public String sumRule(String term1, String term2) throws InvalidExpression{
		if(term1.equals(""))
			return getDerivative(term2);
		else if(term2.equals(""))
			return getDerivative(term1);
		else
			return getDerivative(term2) + "+" + getDerivative(term1);
	}
	/**
	 * Applies the difference rule on two terms. Does not simplify after difference
	 * rule is applied. A valid simplified term using the 'x' variable is expected in order
	 * to work properly. 
	 * @param term1 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on
	 * the left side of the subtraction sign.
	 * @param term2 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on 
	 * the right side of the subtraction sign.
	 * @return the unsimplified derivative 
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public String differenceRule(String term1, String term2) throws InvalidExpression{
		
		if(term1.equals(""))
			return "-" + getDerivative(term2);
		else if(term2.equals(""))
			return  getDerivative(term1);
		else
			return getDerivative(term1) + "-" + getDerivative(term2);
		
	}
	/**
	 * Differentiates a single term and returns the derivative. Applies
	 * the power rule(https://en.wikipedia.org/wiki/Power_rule) to 
	 * differentiate. The variable used must be'x' or the derivative will be incorrect.  Only numbers 
	 * are in the variable's exponent.Rounds to at most 2 decimal places and gets 
	 * rid of unnecessary zeros. If the term is a parenthetical expression then the
	 * chain rule (https://en.wikipedia.org/wiki/Chain_rule) is applied.
	 * @param term - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2".
	 * @return the derivative
	 * @throws InvalidExpression- when a term contains non-numbers where they aren't expected.
	 */
	public String getDerivative(String term) throws InvalidExpression{
		//if there a unexpected characters
		if(term.matches(".*[^x^0-9()\\[\\]\\+\\-\\*\\/].*") && !term.contains("&")){
			throw new InvalidExpression(term + " is not a valid term");
		}
		//derivative of a constant is 0
		if(!term.contains("x")){
			return "0";
		}
		if(term.contains("(")){
			return applyChainRule(term);
		}	
		String coefficient = Reader.readCoefficient(term);
		String power = Reader.readPower(term);
		
		double coef = 0, pow = 0;
		
		try{
			coef = Reader.stringToDouble(coefficient);
			pow = Reader.stringToDouble(power);
		}catch(NumberFormatException nfex){
			throw new InvalidExpression(expression.getOriginalExpression() + " could not be differentiated.");
		}
		
		//For rounding to at most 2 decimal places
		DecimalFormat df = new DecimalFormat("#.##");
		
		//Differentiate by applying power rule.
		if(pow - 1 != 0){
			coef = coef * pow;
			pow = pow - 1;
			
			String formattedCoef = df.format(coef);
			String formattedPow = df.format(pow);
			
			return formattedCoef + "x" + "^" + formattedPow;	
		}else{	
			String formattedCoef = df.format(coef);
			return String.valueOf(formattedCoef);
		}
	}
	/**
	 * Applies the chain rule (https://en.wikipedia.org/wiki/Chain_rule) to a 
	 * term in parenthesis. Only the 'x' variable should be used. Does not simplify 
	 * the answer.
	 * @param term a valid expression in parenthesis.
	 * @return
	 * @throws InvalidExpression - When the expression in parenthesis can't be differentiated.
	 */
	private String applyChainRule(String term) throws InvalidExpression{
		
		int endOfParen = term.indexOf(')') + 1;
		//For separating negative sign from parenthetical expression
		boolean negativeTerm = false;
		if(term.charAt(0) == '-'){
			negativeTerm = true;
		}
		
		//if there are unexpected characters after a parenthesis
		if(endOfParen - 1 == term.length() && term.charAt(endOfParen+1) != '^'){
			throw new InvalidExpression(term + " is not a valid term.");
		}
		
		//if just a expression with parenthesis
		if(term.length() == endOfParen){
			Expression ex = new Expression(term.replaceAll("[()]", ""));
			return "(" + differentiate(ex.getPostfixExpression()) + ")";
		}
		//if exponent is 0 derivative is 0
		try{
		if(Reader.stringToDouble(Reader.readPower( term.substring(endOfParen,term.length()))) == 0){
			return "0";
		}
		}catch(NumberFormatException nfe){
			throw new InvalidExpression(term + " is not a valid term");
		}
		
		String insideParen = "";
		if(negativeTerm){
			insideParen = term.substring(1,endOfParen);
		}else{
			insideParen = term.substring(0, endOfParen);
		}
		String insideParenNoParen = insideParen.replaceAll("[()]", "");
		Expression parenExpression = new Expression(insideParenNoParen);
		
		String derivativeOfParenExp = "";
		derivativeOfParenExp = differentiate(parenExpression.getPostfixExpression());

		//read power of parenthetical expression
		String parenPower = Reader.readPower( term.substring(endOfParen,term.length()) );
		double valueOfParenPower = 0;		
		valueOfParenPower = Reader.stringToDouble(parenPower);
		
		DecimalFormat df = new DecimalFormat("#.##");;
		String parenPowerMinusOne = String.valueOf(df.format(valueOfParenPower-1));
		
		derivativeOfParenExp = "(" + derivativeOfParenExp + ")";
		
		String result = "(" + parenPower + derivativeOfParenExp +")*" + insideParen + "^" + parenPowerMinusOne;
		//put back negative sign
		if(negativeTerm){
			result = "-" + result;
		}
		return result;
	}

}
