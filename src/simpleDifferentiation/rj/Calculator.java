package simpleDifferentiation.rj;

import java.text.DecimalFormat;
import java.util.EmptyStackException;
import java.util.Stack;
/**
 * Used for differentiating postfix expressions. Will only work
 * with the variable 'x'. Formatting is extremely important
 * in order for this class to work properly. Postfix expressions should be generated
 * using the Expression class to guarantee that terms are read properly. Answers 
 * generated by any method of this class will not always be in its simplest form.
 * @author Ryan Jung
 *
 */
public final class Calculator {
	
	//no instances
	private Calculator(){
		
	}
	
	/**
	 * Evaluates a postfix expression and returns the answer. Each term must be separated
	 * with commas(Parenthetical Expressions are considered as a single term). Uses a stack
	 * to differentiate a postfix expression, similarly to how one may use a stack to evaluate
	 * a postfix expression.
	 * 		Example : 5x,(5x^5+5)^5,-
	 * @param expr - A valid postfix expression.
	 * @return The unsimplified derivative of an expression.
	 * @throws InvalidExpression - If a term can't be read or there are more operations
	 * then operands.
	 */
	public static String differentiate(String expr) throws InvalidExpression{
		expr = expr.toLowerCase().replaceAll("\\s+", "");
		
		Stack<String> termStack = new Stack<String>();
		
		int i = 0;
		
		//if there is only one term in the expression
		if(Reader.readTerm(expr, i).length() + 1 == expr.length()){
			return getDerivative(Reader.readTerm(expr, i));
		}
		
		while(i < expr.length()){
			int opToDo = checkOperation(expr.charAt(i));
			//push terms to stack until operation is encountered.
			if(opToDo < 0){
				String term = Reader.readTerm(expr, i);
				termStack.push(term);
				i += term.length() + 1;
			}else{
				try{
					//do operation and put back on stack
					doOperation(termStack, opToDo);
					i++;
				}catch(EmptyStackException esex){
					throw new InvalidExpression("Cannot evaluate. More operations "
							+ "than operands");
				}catch(InvalidExpression iex){
					throw iex;
				}
			}
			
		}
		return termStack.pop().replaceAll("[&]", "");
	}	
	/**
	 * Returns 1 for addition, 2 for subtraction, 3 for multiplication, 4 for
	 * division, and -1 if not an operation.
	 * @param charToRead
	 * @return An integer representing the operation.
	 */
	private static int checkOperation(char charToRead){
		if (charToRead == '+')
			return 1;
		else if (charToRead == '-')
			return 2;
		else if (charToRead == '*')
			return 3;
		else if (charToRead == '/')
			return 4;
		else
			return -1;

	}
	/**
	 * Pops two terms off the term stack and conducts the appropriate operation
	 * for those two terms. Once the resulting derivative has been evaluated
	 * adds an '&' to the end of the result indicating that the term has already been
	 * differentiated and then pushes back the result to the term stack. Note term1
	 * is actually the term after an operator and term2 is the term before the operator.
	 * For example in the expression "5/2" term2 = 5 and term1 = 2. 
	 * @param termStack - A stack containing the expression's terms
	 * @param opToDo - An operation (1 = '+' , 2 = '-' , 3 = '*', 4 = '/').
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	private static void doOperation(Stack<String> termStack, int opToDo) throws InvalidExpression{
		String result = "";
		String term1 = termStack.pop(); 
		String term2 = termStack.pop();
		switch(opToDo){
		
			case 1:		
				// '&' implies derivative has already been calculated for a term
				if(term2.contains("&")){
					result = sumRule(term1, "")+ "+" + term2;
				}else
					result = sumRule(term1, term2);
				
				break;	
	
			case 2:
				if(term2.contains("&")){
					result = term2 + differenceRule("" , term1);
				}else{
					result = differenceRule(term2, term1);
				}	
				break;
				
			case 3:
				result = productRule(term1, term2);
				break;
				
			case 4:
				result = quotientRule(term2,term1);
				break;		
		}
		result+= "&";
		
		termStack.push(result);
				
	}
	/**
	 * Applies the product rule (https://en.wikipedia.org/wiki/Product_rule)
	 * to two terms. Does not fully simplify the answer.
	 * @param term1 - A simplified term eg. "25x^2" instead of "5^2x^2".
	 * @param term2 - A simplified term eg. "25x^2" instead of "5^2x^2".
	 * @return 
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public static String productRule(String term1, String term2) throws InvalidExpression{
		
		String derivTerm1 = getDerivative(term1);
		String derivTerm2 = getDerivative(term2);
		
		String term1TimesDerivTerm2 = "";
		String derivTerm1TimesTerm2 = "";
		//Since terms involving chain rule are more difficult to multiply leave it unsimplified
		if(derivTerm2.contains("(") || term1.contains("(")){
			term1TimesDerivTerm2 = term1 + "*" + derivTerm2;
		}
		if(derivTerm1.contains("(") || term2.contains("(")){
			derivTerm1TimesTerm2 = derivTerm1 + "*" + term2;
		}
		
		//No chain rule -> multiply
		if(derivTerm1TimesTerm2.equals("")){
			derivTerm1TimesTerm2 = multiply(derivTerm1, term2);
		}
		if(term1TimesDerivTerm2.equals("")){
			term1TimesDerivTerm2 = multiply(derivTerm2, term1);
		}
		
		return derivTerm1TimesTerm2 + "+" + term1TimesDerivTerm2;
	}
	/**
	 * Multiplies two terms together. Only works with the variable 'x'.
	 * @param term1 - A simplified term eg. "25x^2" instead of "5^2x^2".
	 * @param term2 - A simplified term eg. "25x^2" instead of "5^2x^2".
	 * @return the result 
	 */
	private static String multiply(String term1, String term2){	
		
		double coefTerm1 = Reader.stringToDouble(Reader.readCoefficient(term1));
		double coefTerm2 = Reader.stringToDouble(Reader.readCoefficient(term2));
		double coefT1timescoefT2 = coefTerm1 * coefTerm2;
		
		double powTerm1 = Reader.stringToDouble(Reader.readPower(term1));
		double powTerm2 = Reader.stringToDouble(Reader.readPower(term2));
		double term1powPlusTerm2pow = powTerm1 + powTerm2; 
		
		//round to at most 2 places, get rid of unnecessary zeros.
		DecimalFormat df = new DecimalFormat("#.##");
		String formattedCoefficient = df.format(coefT1timescoefT2);
		String formattedPower = df.format(term1powPlusTerm2pow);
		
		//if both terms are constants
		if(term1powPlusTerm2pow == 0){
			return formattedCoefficient;
		}else if(term1powPlusTerm2pow != 1){
			return formattedCoefficient + "x^" + formattedPower;
		}else{
			return formattedCoefficient + "x";
		}
		
		
	}
	/**
	 * Applies the quotient rule (https://en.wikipedia.org/wiki/Quotient_rule) for 
	 * differentiation involving division. The resulting answer will not be in its simplest
	 * form.
	 * @param term1 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on the left
	 * side of the '/' sign.
	 * @param term2 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on the right
	 * side of the '/' sign.
	 * @return
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public static String quotientRule(String term1, String term2) throws InvalidExpression{
		
		String derivTerm1 = getDerivative(term1);	
		String derivTerm2 = getDerivative(term2);
		
		String derivTerm1TimesTerm2 = "";
		String derivTerm2TimesTerm1 = "";
		//Since terms involving chain rule are more difficult to multiply leave it unsimplified
		if(derivTerm2.contains("(") || term1.contains("(")){
			derivTerm2TimesTerm1 =  derivTerm2 + "*" + term1 ;
		}
		if(derivTerm1.contains("(") || term2.contains("(")){
			derivTerm1TimesTerm2 = derivTerm1 + "*" + term2;
		}

		//No chain rule -> multiply
		if(derivTerm1TimesTerm2.equals("")){
			derivTerm1TimesTerm2 = multiply(derivTerm1, term2);
		}
		if(derivTerm2TimesTerm1.equals("")){
				derivTerm2TimesTerm1 = multiply(derivTerm2, term1);
		}
		
		String numerator = "[" + derivTerm1TimesTerm2 + "-" + derivTerm2TimesTerm1 + "]";
		String denominator = "";
		if(term2.contains("(")){
			denominator = "[" + term2 + "]" + "^2";
		}else{
			denominator = "(" + multiply(term2, term2) + ")";
		}
		return numerator + "/" + denominator; 
	}
	/**
	 * Applies the sum rule (https://en.wikipedia.org/wiki/Sum_rule_in_differentiation)
	 * on two terms. Does not simplify after sum rule is applied. A valid simplified
	 * term using the 'x' variable is expected in order to work properly.
	 * @param term1 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2".
	 * @param term2 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2".
	 * @return the unsimplified derivative
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public static String sumRule(String term1, String term2) throws InvalidExpression{
		if(term1.equals(""))
			return getDerivative(term2);
		else if(term2.equals(""))
			return getDerivative(term1);
		else
			return getDerivative(term2) + "+" + getDerivative(term1);
	}
	/**
	 * Applies the difference rule on two terms. Does not simplify after difference
	 * rule is applied. A valid simplified term using the 'x' variable is expected in order
	 * to work properly. 
	 * @param term1 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on
	 * the left side of the subtraction sign.
	 * @param term2 - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2" on 
	 * the right side of the subtraction sign.
	 * @return the unsimplified derivative 
	 * @throws InvalidExpression - When a term is invalid. eg. Uses variables other than 'x'
	 * or contains non-numbers in the exponent or coefficient.
	 */
	public static String differenceRule(String term1, String term2) throws InvalidExpression{
		
		if(term1.equals(""))
			return "-" + getDerivative(term2);
		else if(term2.equals(""))
			return  getDerivative(term1);
		else
			return getDerivative(term1) + "-" + getDerivative(term2);
		
	}
	/**
	 * Differentiates a single term and returns the derivative. Applies
	 * the power rule(https://en.wikipedia.org/wiki/Power_rule) to 
	 * differentiate. The variable used must be'x' or the derivative will be incorrect.  Only numbers 
	 * are in the variable's exponent.Rounds to at most 2 decimal places and gets 
	 * rid of unnecessary zeros. If the term is a parenthetical expression then the
	 * chain rule (https://en.wikipedia.org/wiki/Chain_rule) is applied.
	 * @param term - A simplified term eg. "25x^2" instead of "(50/2)x^2" or "5^2x^2".
	 * @return the derivative
	 * @throws InvalidExpression- when a term contains non-numbers where they aren't expected.
	 */
	public static String getDerivative(String term) throws InvalidExpression{
		//if there a unexpected characters
		if(term.matches(".*[^x^0-9()\\[\\]].*")){
			throw new InvalidExpression(term + " is not a valid term");
		}
		//derivative of a constant is 0
		if(!term.contains("x")){
			return "0";
		}
		if(term.contains("(")){
			return applyChainRule(term);
		}	
		String coefficient = Reader.readCoefficient(term);
		String power = Reader.readPower(term);
		
		double coef = 0, pow = 0;
		
		try{
			coef = Reader.stringToDouble(coefficient);
			pow = Reader.stringToDouble(power);
		}catch(NumberFormatException nfex){
			throw new InvalidExpression(term + " could not be differentiated.");
		}
		
		//For rounding to at most 2 decimal places
		DecimalFormat df = new DecimalFormat("#.##");
		
		//Differentiate by applying power rule.
		if(pow - 1 != 0){
			coef = coef * pow;
			pow = pow - 1;
			
			String formattedCoef = df.format(coef);
			String formattedPow = df.format(pow);
			
			return formattedCoef + "x" + "^" + formattedPow;	
		}else{
			
			String formattedCoef = df.format(coef);
			return String.valueOf(formattedCoef);
		}
	}
	/**
	 * Applies the chain rule (https://en.wikipedia.org/wiki/Chain_rule) to a 
	 * term in parenthesis. Only the 'x' variable should be used. Does not simplify 
	 * the answer.
	 * @param term a valid expression in parenthesis.
	 * @return
	 * @throws InvalidExpression - When the expression in parenthesis can't be differentiated.
	 */
	private static String applyChainRule(String term) throws InvalidExpression{
		
		int endOfParen = term.indexOf(')') + 1;
		
		//if there are unexpected characters after a parenthesis
		if(endOfParen - 1 == term.length() && term.charAt(endOfParen+1) != '^'){
			throw new InvalidExpression(term + " is not a valid term.");
		}
		
		//if just a expression with parenthesis
		if(term.length() == endOfParen){
			Expression ex = new Expression(term.replaceAll("[()]", ""));
			return "(" + differentiate(ex.getPostfixExpression()) + ")";
		}
		//if exponent is 0 derivative is 0
		if(Reader.stringToDouble(Reader.readPower( term.substring(endOfParen,term.length()))) == 0){
			return "0";
		}
		
		String insideParen = term.substring(0, endOfParen);
		String insideParenNoParen = insideParen.replaceAll("[()]", "");
		Expression parenExpression = new Expression(insideParenNoParen);
		
		String derivativeOfParenExp = "";
		derivativeOfParenExp = differentiate(parenExpression.getPostfixExpression());

		//read power of parenthetical expression
		String parenPower = Reader.readPower( term.substring(endOfParen,term.length()) );
		double valueOfParenPower = 0;		
		valueOfParenPower = Reader.stringToDouble(parenPower);
		
		DecimalFormat df = new DecimalFormat("#.##");;
		String parenPowerMinusOne = String.valueOf(df.format(valueOfParenPower-1));
		
		derivativeOfParenExp = "(" + derivativeOfParenExp + ")";
		
		String result = "[" + parenPower + derivativeOfParenExp +"]" + insideParen + "^" + parenPowerMinusOne;
		return result;
	}

}
